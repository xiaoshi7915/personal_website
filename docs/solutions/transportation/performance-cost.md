# 8. 性能与成本

## 8.1 弹性伸缩

### 伸缩策略

智能交通解决方案采用弹性伸缩策略，根据负载自动调整资源：

#### 自动伸缩规则

**1. 基于CPU使用率**
- **扩容阈值**：CPU使用率 > 70%，持续5分钟
- **缩容阈值**：CPU使用率 < 30%，持续10分钟
- **扩容步长**：每次增加2个实例
- **缩容步长**：每次减少1个实例

**2. 基于内存使用率**
- **扩容阈值**：内存使用率 > 80%，持续5分钟
- **缩容阈值**：内存使用率 < 40%，持续10分钟

**3. 基于请求量**
- **扩容阈值**：QPS > 1000，持续3分钟
- **缩容阈值**：QPS < 200，持续15分钟

**4. 基于队列长度**
- **扩容阈值**：任务队列长度 > 100，持续2分钟
- **缩容阈值**：任务队列长度 < 10，持续10分钟

#### Kubernetes HPA配置

```yaml
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: transportation-api-hpa
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: transportation-api
  minReplicas: 3
  maxReplicas: 20
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80
    - type: Pods
      pods:
        metric:
          name: http_requests_per_second
        target:
          type: AverageValue
          averageValue: "1000"
```

### 资源调度

#### 资源分配策略

**1. 请求优先级**
- **高优先级**：实时交通调度、安全预警、紧急响应
- **中优先级**：路径规划、停车查询、常规预测
- **低优先级**：历史数据分析、批量任务、非紧急任务

**2. 资源预留**
- **预留资源**：为高优先级任务预留20%资源
- **弹性资源**：剩余80%资源按需分配

**3. 资源隔离**
- **CPU隔离**：使用CPU限制和请求
- **内存隔离**：使用内存限制和请求
- **网络隔离**：使用网络策略

#### 资源调度配置

```yaml
apiVersion: v1
kind: Pod
metadata:
  name: transportation-api-pod
spec:
  containers:
    - name: transportation-api
      image: transportation-api:latest
      resources:
        requests:
          cpu: "1000m"
          memory: "2Gi"
        limits:
          cpu: "2000m"
          memory: "4Gi"
      priorityClassName: "high-priority"
```

## 8.2 缓存策略

### 缓存层级

#### 1. 应用层缓存（Redis）

**缓存内容**：
- 热点交通数据（实时路况、拥堵信息）
- 路径规划结果（相同起终点的路径）
- 停车位信息（停车场列表、可用车位）
- 用户会话信息

**缓存策略**：
- **TTL设置**：
  - 实时路况：30秒
  - 路径规划：5分钟
  - 停车位信息：1分钟
  - 用户会话：30分钟

**缓存配置**：
```python
import redis

redis_client = redis.Redis(
    host='redis-server',
    port=6379,
    db=0,
    decode_responses=True
)

# 缓存实时路况
def cache_traffic_data(road_id, data, ttl=30):
    key = f"traffic:{road_id}"
    redis_client.setex(key, ttl, json.dumps(data))

# 获取缓存数据
def get_cached_traffic_data(road_id):
    key = f"traffic:{road_id}"
    data = redis_client.get(key)
    return json.loads(data) if data else None
```

#### 2. CDN缓存

**缓存内容**：
- 静态资源（JS、CSS、图片）
- API响应（GET请求的响应）
- 地图瓦片

**缓存策略**：
- **静态资源**：长期缓存（1年），使用版本号控制更新
- **API响应**：短期缓存（1-5分钟），根据数据更新频率调整
- **地图瓦片**：中期缓存（1小时）

#### 3. 数据库查询缓存

**缓存内容**：
- 频繁查询的数据库结果
- 历史交通数据聚合结果
- 用户偏好数据

**缓存策略**：
- **查询结果缓存**：5-30分钟，根据数据更新频率调整
- **聚合结果缓存**：1-24小时，根据聚合粒度调整

### 缓存更新策略

#### 1. 主动更新

**定时更新**：
- 实时路况：每30秒更新一次
- 停车位信息：每1分钟更新一次
- 路径规划：根据路况变化触发更新

**事件驱动更新**：
- 交通异常事件触发路况更新
- 停车位状态变化触发停车信息更新
- 用户操作触发相关缓存更新

#### 2. 被动更新

**缓存失效**：
- TTL到期自动失效
- 数据更新时主动失效
- 手动清除缓存

**缓存穿透防护**：
- 使用布隆过滤器过滤无效请求
- 对空结果进行短期缓存
- 限制查询频率

## 8.3 数据库优化

### 数据库设计

#### 1. 表结构优化

**索引设计**：
- **主键索引**：所有表都有主键索引
- **外键索引**：外键字段建立索引
- **查询字段索引**：频繁查询的字段建立索引
- **组合索引**：多字段组合查询建立组合索引

**分区设计**：
- **时间分区**：按时间分区存储历史数据
- **地理分区**：按地理位置分区存储数据
- **哈希分区**：按哈希值分区存储数据

#### 2. 查询优化

**SQL优化**：
- 避免全表扫描
- 使用索引优化查询
- 避免SELECT *
- 使用LIMIT限制结果集

**连接优化**：
- 使用INNER JOIN替代子查询
- 避免多表连接
- 使用EXPLAIN分析查询计划

### 读写分离

#### 主从复制

**主库**：
- 处理写操作
- 实时数据写入
- 高可用配置

**从库**：
- 处理读操作
- 数据查询和分析
- 负载均衡

**配置示例**：
```yaml
# 主库配置
master:
  host: postgres-master
  port: 5432
  database: transportation_db
  user: postgres
  password: password

# 从库配置
slaves:
  - host: postgres-slave-1
    port: 5432
    database: transportation_db
    user: postgres
    password: password
  - host: postgres-slave-2
    port: 5432
    database: transportation_db
    user: postgres
    password: password
```

## 8.4 成本优化

### 计算资源成本优化

#### 1. 实例类型选择

**CPU密集型任务**：
- 使用CPU优化实例
- 路径规划、信号优化等任务

**内存密集型任务**：
- 使用内存优化实例
- 大数据分析、模型推理等任务

**GPU任务**：
- 使用GPU实例
- 计算机视觉、深度学习模型推理

#### 2. 预留实例

**预留实例策略**：
- **1年期预留**：节省30-40%成本
- **3年期预留**：节省50-60%成本
- **可转换预留**：灵活性更高

**使用场景**：
- 稳定的基础负载
- 长期运行的服务
- 可预测的流量模式

#### 3. Spot实例

**Spot实例策略**：
- 使用Spot实例处理可中断任务
- 节省60-90%成本
- 适合批处理任务、数据分析任务

**使用场景**：
- 历史数据分析
- 模型训练
- 批量数据处理

### 存储成本优化

#### 1. 存储类型选择

**热数据**：
- 使用SSD存储
- 实时数据、频繁访问数据

**温数据**：
- 使用标准存储
- 近期数据、中等访问频率数据

**冷数据**：
- 使用归档存储
- 历史数据、低频访问数据

#### 2. 数据生命周期管理

**数据分层**：
- **热数据层**：最近7天数据，SSD存储
- **温数据层**：7-30天数据，标准存储
- **冷数据层**：30天以上数据，归档存储

**自动归档**：
- 自动将旧数据迁移到归档存储
- 根据访问频率自动调整存储类型
- 定期清理无用数据

### API调用成本优化

#### 1. 请求合并

**批量请求**：
- 合并多个小请求为批量请求
- 减少API调用次数
- 降低API成本

**请求去重**：
- 识别重复请求
- 使用缓存结果
- 避免重复API调用

#### 2. 模型选择优化

**成本效益分析**：
- 根据任务复杂度选择模型
- 简单任务使用低成本模型
- 复杂任务使用高性能模型

**模型缓存**：
- 缓存模型推理结果
- 减少重复推理
- 降低推理成本

## 8.5 性能监控

### 性能指标

#### 1. 响应时间

**目标指标**：
- **API响应时间**：P95 < 500ms，P99 < 1000ms
- **路径规划响应时间**：< 30秒
- **停车查询响应时间**：< 10秒
- **流量预测响应时间**：< 5秒

#### 2. 吞吐量

**目标指标**：
- **API QPS**：> 1000
- **并发用户数**：> 10000
- **数据处理量**：> 100万条/小时

#### 3. 资源使用率

**目标指标**：
- **CPU使用率**：< 70%
- **内存使用率**：< 80%
- **磁盘使用率**：< 80%
- **网络带宽使用率**：< 70%

### 性能监控工具

#### 1. Prometheus + Grafana

**监控指标**：
- 系统指标（CPU、内存、磁盘、网络）
- 应用指标（请求数、响应时间、错误率）
- 业务指标（预测准确率、路径规划成功率）

**告警规则**：
- CPU使用率 > 80%持续5分钟
- 内存使用率 > 90%持续5分钟
- API响应时间 > 1秒持续10分钟
- 错误率 > 5%持续5分钟

#### 2. APM工具

**应用性能监控**：
- 请求追踪
- 性能分析
- 错误追踪
- 依赖分析

